This repository contains a Python implementation of both Depth-First Search (DFS) and Breadth-First Search (BFS) algorithms for solving the 0/1 Knapsack problem. The code defines a `node` class that represents the state of an item being either included in or excluded from the knapsack and encapsulates its weight, benefit, and position within the solution space. The `knapsack` function can operate in two modes: DFS using a stack and BFS using a queue, allowing for the exploration of the solution space either depth-wise or breadth-wise.

The solution is built incrementally, tracking the maximum benefit found that fits within the knapsack's capacity constraint. The implementation reads a list of items, each with a weight and benefit, from a file and determines the optimal combination of items that maximizes the total benefit without exceeding the knapsack's capacity. The algorithm backtracks to construct the solution path from the optimal node to the root, resulting in a list indicating the inclusion of each item.

Performance is measured using the `timeit` library, with the script outputting the original item list, maximum benefit, total weight of the selected items, the solution path, and the elapsed time for the computation. This repository is ideal for educational purposes, demonstrating two fundamental search algorithms applied to a classic optimization problem.
